package main

import (
	"fmt"
)

func main() {
	aValue := new(int)
	*aValue = 1
	defer fmt.Println(*aValue) //go 中的defer 中的值，是最初给定的值不会吗随着当前地址的数据的变化而变化
	for i := 0; i < 100; i++ {
		*aValue++
	}

	fmt.Println(*aValue)
}



2） go range 传值的方式 ，range的内容只获取一次

	jk := []int{12, 334, 45}
	for k, v := range jk {
		jk = append(jk, v+1)
		fmt.Println(k, v)
	}
	
//0 12
//1 334
//2 45


3) go 中的select的值能随机 带来数据的不确定性
package main

import (
	"fmt"
	"runtime"
)

func main() {
	runtime.GOMAXPROCS(1)
	int_chan := make(chan int, 1)
	string_chan := make(chan string, 1)
	int_chan <- 1
	string_chan <- "222"
	select {
	case value := <-int_chan:
		fmt.Println(value)
	case value := <-string_chan:
		fmt.Println("string func a", value)
	}
}

//select is random  you dot't know of which one is first run



