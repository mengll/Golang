package main

import (
	"fmt"
)

func main() {
	aValue := new(int)
	*aValue = 1
	defer fmt.Println(*aValue) //go 中的defer 中的值，是最初给定的值不会吗随着当前地址的数据的变化而变化
	for i := 0; i < 100; i++ {
		*aValue++
	}

	fmt.Println(*aValue)
}



2） go range 传值的方式 ，range的内容只获取一次

	jk := []int{12, 334, 45}
	for k, v := range jk {
		jk = append(jk, v+1)
		fmt.Println(k, v)
	}
	
//0 12
//1 334
//2 45


3) go 中的select的值能随机 带来数据的不确定性
package main

import (
	"fmt"
	"runtime"
)

func main() {
	runtime.GOMAXPROCS(1)
	int_chan := make(chan int, 1)
	string_chan := make(chan string, 1)
	int_chan <- 1
	string_chan <- "222"
	select {
	case value := <-int_chan:
		fmt.Println(value)
	case value := <-string_chan:
		fmt.Println("string func a", value)
	}
}

//select is random  you dot't know of which one is first run

4)golang 中的赋值操作 都会拷贝一份 及深拷贝

	m := make(map[string]int)
	m["kl"] = 9
	m["pl"] = 10
	fmt.Println("map:", m)

	//delete one key

	delete(m, "kl")

	fmt.Println("map delete one key", m)
	c := m

	fmt.Println(&m == &c) //daochu dangqiande duixaing
	fmt.Println(&c)

	j := 1
	k := 1

	fmt.Println(&j == &k) //The value of data is not the

5）传值 和传递引用
	func inflate(numbers [9]int, factor int) {
		for i := range numbers {
			numbers[i] *= factor
		}
	}
	
	
	grades := [9]int{87, 55, 43, 71, 60, 43, 32, 19, 63}
	inflate(grades, 3)
	fmt.Println(grades)

	for ij := range grades {
		grades[ij] *= 2
	}
	fmt.Println(grades)
	echo //扩展数组在方法传递 的是复制了一份。  []int 是切片传递给方法的时候传递的是引用
	[87 55 43 71 60 43 32 19 63]
	[174 110 86 142 120 86 64 38 126]

6）获取当前的路径
	path, err := os.Getwd()

